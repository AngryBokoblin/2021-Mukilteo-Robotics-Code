# VEX V5 Python Project with Competition Template
import sys
import vex
from vex import *
import motor_group
import drivetrain
import smartdrive
import math
import timer

#region config
brain       = vex.Brain()
arm_        = vex.Motor(vex.Ports.PORT4, vex.GearSetting.RATIO18_1, False)
arm2_       = vex.Motor(vex.Ports.PORT5, vex.GearSetting.RATIO18_1, True)
claw        = vex.Motor(vex.Ports.PORT11, vex.GearSetting.RATIO18_1, True)
right2      = vex.Motor(vex.Ports.PORT16, vex.GearSetting.RATIO18_1, True)
left2       = vex.Motor(vex.Ports.PORT17, vex.GearSetting.RATIO18_1, False)
left        = vex.Motor(vex.Ports.PORT18, vex.GearSetting.RATIO18_1, False)
right       = vex.Motor(vex.Ports.PORT19, vex.GearSetting.RATIO18_1, True)
inertial_21 = vex.Inertial(vex.Ports.PORT21)
con         = vex.Controller(vex.ControllerType.PRIMARY)
#endregion config


# Creates a competition object that allows access to Competition methods.
competition = vex.Competition()


def findPower(current, wanted, intensity, Kp, Ki):
    global done, totalError, power
    error =  wanted - current 
    power = Kp*error + Ki*totalError
    if power > intensity:
        power = intensity
    if power*-1 > intensity:
        power = -1*intensity
    if abs(error) <= 5:
        done = True
    totalError += error

def pre_auton():
    # All activities that occur before competition start
    # Example: setting initial positions
    pass

def autonomous():
    global done, totalError, power
    # Place autonomous code here
    inertial_21.calibrate()
    timer_ = timer.Timer()
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    claw.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -460, 60, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), 300, 20, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -330, 60, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), 260, 100, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -450, 60, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), 290, 100, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), 270, 100, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    vex.wait(0.3,vex.SECONDS)
    timer_.reset()
    timer_.start()
    while not done:
        findPower(claw.rotation(vex.DEGREES), -500, 100, .5, .001)
        claw.spin(vex.FORWARD, power, vex.PERCENT)
        if timer_.elapsed_time()>2:
            done = True
    timer_.stop()
    claw.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -550, 30, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    vex.wait(0.3,vex.SECONDS)
    while not done: 
        findPower(right.rotation(vex.DEGREES), 1000, 20, .5, .001)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, right.rotation(vex.DEGREES))
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    arm_.stop(vex.BrakeType.COAST)
    arm2_.stop(vex.BrakeType.COAST)
    vex.wait(.5,vex.SECONDS)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
   

def drivercontrol():
    global done, totalError, power
    # Place drive control code here, inside the loop
    left.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    rightPower = 0
    leftPower = 0 
    done = False
    timer_1 = timer.Timer()
    cntrlO = 0
    mode = 0
    timer_1.start()
    #auton test code:
    #end auton code
    
    while True:
        # This is the main loop for the driver control.
        # Each time through the loop you should update motor
        # movements based on input from the controller.
        #cntrlO = 0
        #mode = 0 
        #Derek: "hmm I can't figure out why this doesn't work"
        #maybe because we are setting it to 0 every 2 milliseconds!
        if con.buttonA.pressing():
            if cntrlO == 0:
                mode += 1
                mode %= 3
                
                cntrlO = 1
                timer_1.reset()
                timer_1.start()
        if timer_1.elapsed_time() > .9:
            cntrlO = 0
            brain.screen.print_line(4, "I was here")
            
        
        if -1 < con.axis2.position(vex.PERCENT) and con.axis2.position(vex.PERCENT) < 1:
            right2.stop(vex.BrakeType.HOLD)
            right.stop(vex.BrakeType.HOLD)
            rightPower=0
        elif mode == 2: #7th polynomial equation for scaling
            rightPower = con.axis2.position(vex.PERCENT)**7.  - 3 * con.axis2.position(vex.PERCENT)**5. + 3 * con.axis2.position(vex.PERCENT)**3.  - con.axis2.position(vex.PERCENT)
            rightPower /= (99**3.) * (101**3.)
            right.spin(vex.FORWARD, math.floor(rightPower), vex.PERCENT)
            right2.spin(vex.FORWARD, math.floor(rightPower), vex.PERCENT)
        elif mode == 1: # 5th power polynomial for scaling
            rightPower = con.axis2.position(vex.PERCENT)**5.  - 2 * con.axis2.position(vex.PERCENT)**3. + con.axis2.position(vex.PERCENT)
            rightPower /= (99**2) * (101**2)
            right.spin(vex.FORWARD, math.floor(rightPower), vex.PERCENT)
            right2.spin(vex.FORWARD, math.floor(rightPower), vex.PERCENT)
        else: #cubic
            rightPower = con.axis2.position(vex.PERCENT)**3 + con.axis2.position(vex.PERCENT)
            rightPower /= 9999
            right.spin(vex.FORWARD, math.floor(rightPower), vex.PERCENT)
            right2.spin(vex.FORWARD, math.floor(rightPower), vex.PERCENT)
            
        if -5 < con.axis3.position(vex.PERCENT) and con.axis3.position(vex.PERCENT) < 5:
            left2.stop(vex.BrakeType.HOLD)
            left.stop(vex.BrakeType.HOLD)
            leftPower = 0
        elif mode == 2:
            leftPower = con.axis3.position(vex.PERCENT)**7.  - 3 * con.axis3.position(vex.PERCENT)**5. + 3 * con.axis3.position(vex.PERCENT)**3.  - con.axis3.position(vex.PERCENT)
            leftPower /= (99**3.) * (101**3.)
            left.spin(vex.FORWARD, math.floor(leftPower), vex.PERCENT)
            left2.spin(vex.FORWARD, math.floor(leftPower), vex.PERCENT)
        elif mode == 1:
            leftPower = con.axis3.position(vex.PERCENT)**5.  - 2 * con.axis3.position(vex.PERCENT)**3. + con.axis3.position(vex.PERCENT)
            leftPower /= (99**2) * (101**2)
            left.spin(vex.FORWARD, math.floor(leftPower), vex.PERCENT)
            left2.spin(vex.FORWARD, math.floor(leftPower), vex.PERCENT)
        else:
            leftPower = con.axis3.position(vex.PERCENT)**3 + con.axis3.position(vex.PERCENT)
            leftPower /= 9999
            left.spin(vex.FORWARD, math.floor(leftPower), vex.PERCENT)
            left2.spin(vex.FORWARD, math.floor(leftPower), vex.PERCENT)
        
        if con.buttonL1.pressing():
            arm_.spin(vex.REVERSE)
            arm2_.spin(vex.REVERSE)
        elif con.buttonL2.pressing():
            arm_.spin(vex.FORWARD)
            arm2_.spin(vex.FORWARD)
        else:
            arm_.stop(vex.BrakeType.HOLD)
            arm2_.stop(vex.BrakeType.HOLD)
            
        if con.buttonR1.pressing():
            claw.spin(vex.REVERSE)
        elif con.buttonR2.pressing():
            claw.spin(vex.FORWARD)
        else:
            claw.stop(vex.BrakeType.HOLD)
        brain.screen.print_line(1, math.floor(rightPower))
        brain.screen.print_line(2, math.floor(leftPower))
        brain.screen.print_line(3, mode)
        

# Do not adjust the lines below

# Set up (but don't start) callbacks for autonomous and driver control periods.
competition.autonomous(autonomous)
competition.drivercontrol(drivercontrol)

# Run the pre-autonomous function.
pre_auton()

# Robot Mesh Studio runtime continues to run until all threads and
# competition callbacks are finished.
