# VEX V5 Python Project with Competition Template
import sys
import vex
from vex import *
import motor_group
import drivetrain
import smartdrive
import math
import timer

#region config
brain       = vex.Brain()
arm_        = vex.Motor(vex.Ports.PORT4, vex.GearSetting.RATIO18_1, False)
arm2_       = vex.Motor(vex.Ports.PORT5, vex.GearSetting.RATIO18_1, True)
claw        = vex.Motor(vex.Ports.PORT11, vex.GearSetting.RATIO18_1, True)
right2      = vex.Motor(vex.Ports.PORT16, vex.GearSetting.RATIO18_1, True)
left2       = vex.Motor(vex.Ports.PORT17, vex.GearSetting.RATIO18_1, False)
left        = vex.Motor(vex.Ports.PORT18, vex.GearSetting.RATIO18_1, False)
right       = vex.Motor(vex.Ports.PORT19, vex.GearSetting.RATIO18_1, True)
inertial_21 = vex.Inertial(vex.Ports.PORT21)
con         = vex.Controller(vex.ControllerType.PRIMARY)
#endregion config


# Creates a competition object that allows access to Competition methods.
competition = vex.Competition()


def findPower(current, wanted, intensity, Kp, Ki):
    global done, totalError, power
    error =  wanted - current 
    power = Kp*error + Ki*totalError
    if power > intensity:
        power = intensity
    if power*-1 > intensity:
        power = -1*intensity
    if abs(error) <= 5:
        done = True
    totalError += error

def pre_auton():
    # All activities that occur before competition start
    # Example: setting initial positions
    pass

def autonomous():
    global done, totalError, power
    # Place autonomous code here
    inertial_21.calibrate()
    timer_ = timer.Timer()
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    claw.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -460, 60, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        autonAngle = inertial_21.heading(vex.DEGREES)
        if autonAngle > 180:
            autonAngle -= 360
        findPower(autonAngle, 55, 20, .5, .001)
        left.spin(vex.REVERSE, power, vex.PERCENT)
        left2.spin(vex.REVERSE, power, vex.PERCENT)
        brain.screen.print_line(6, inertial_21.heading(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), -60, 20, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -330, 60, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), -110, 100, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -450, 60, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), -70, 100, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(left.rotation(vex.DEGREES), -100, 100, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        right.spin(vex.FORWARD, power, vex.PERCENT)
        right2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    vex.wait(0.3,vex.SECONDS)
    timer_.reset()
    timer_.start()
    while not done:
        findPower(claw.rotation(vex.DEGREES), -550, 100, .5, .001)
        claw.spin(vex.FORWARD, power, vex.PERCENT)
        if timer_.elapsed_time()>2:
            done = True
    timer_.stop()
    claw.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    while not done: 
        findPower(arm_.rotation(vex.DEGREES), -550, 30, .5, .001)
        arm_.spin(vex.FORWARD, power, vex.PERCENT)
        arm2_.spin(vex.FORWARD, power, vex.PERCENT)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    vex.wait(0.3,vex.SECONDS)
    while not done: 
        findPower(left.rotation(vex.DEGREES), -400, 20, .5, .001)
        left.spin(vex.FORWARD, power, vex.PERCENT)
        left2.spin(vex.FORWARD, power, vex.PERCENT)
        brain.screen.print_line(5, left.rotation(vex.DEGREES))
    left.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    done = False
    totalError = 0
    arm_.stop(vex.BrakeType.COAST)
    arm2_.stop(vex.BrakeType.COAST)
    vex.wait(.5,vex.SECONDS)
    arm_.stop(vex.BrakeType.HOLD)
    arm2_.stop(vex.BrakeType.HOLD)
   

def drivercontrol():
    global done, totalError, power
    # Place drive control code here, inside the loop
    left.stop(vex.BrakeType.HOLD)
    right.stop(vex.BrakeType.HOLD)
    left2.stop(vex.BrakeType.HOLD)
    right2.stop(vex.BrakeType.HOLD)
    rightPower = 0
    leftPower = 0 
    done = False
    #auton test code:
    #end auton code
    
    while True:
        # This is the main loop for the driver control.
        # Each time through the loop you should update motor
        # movements based on input from the controller.
        
        forwardPower = con.axis2.position(vex.PERCENT) #multipliers can be added
        spinPower = con.axis4.position(vex.PERCENT)
        turnPower = con.axis1.position(vex.PERCENT)
        if turnPower > 0:
            rightPower = forwardPower-spinPower
            leftPower = forwardPower+spinPower+turnPower
        else: 
            rightPower = forwardPower - spinPower - turnPower
            leftPower = forwardPower + spinPower
        right.spin(vex.FORWARD, rightPower, vex.PERCENT)
        right2.spin(vex.FORWARD, rightPower, vex.PERCENT)
        left.spin(vex.FORWARD, leftPower, vex.PERCENT)
        left2.spin(vex.FORWARD, leftPower, vex.PERCENT)
        
        if con.buttonL1.pressing():
            arm_.spin(vex.REVERSE)
            arm2_.spin(vex.REVERSE)
        elif con.buttonL2.pressing():
            arm_.spin(vex.FORWARD)
            arm2_.spin(vex.FORWARD)
        else:
            arm_.stop(vex.BrakeType.HOLD)
            arm2_.stop(vex.BrakeType.HOLD)
            
        if con.buttonR1.pressing():
            claw.spin(vex.REVERSE)
        elif con.buttonR2.pressing():
            claw.spin(vex.FORWARD)
        else:
            claw.stop(vex.BrakeType.HOLD)
        brain.screen.print_line(1, arm_.rotation(vex.DEGREES))
        brain.screen.print_line(2, claw.rotation(vex.DEGREES))

# Do not adjust the lines below

# Set up (but don't start) callbacks for autonomous and driver control periods.
competition.autonomous(autonomous)
competition.drivercontrol(drivercontrol)

# Run the pre-autonomous function.
pre_auton()

# Robot Mesh Studio runtime continues to run until all threads and
# competition callbacks are finished.
